# Solution1
- **核心思想：转变成最长公共子序列的问题，然后DP**
- 一个序列和其自身排序后的序列的最长公共子序列就是原来该序列的最长单调(非严格)子序列，注意此时需要处理掉不严格的情况。
- 最长公共子序列的递推公式如下
```java
// dp[i][j]表示序列a到i为止，序列b到j为止时最长公共子序列长度。
if(nums[i] == ordered[j])  dp[i][j] = dp[i-1][j-1] + 1;
else dp[i][j] = Math.max(dp[i][j-1],dp[i-1][j]);
// 外面两层循环解决，时间复杂度O(n^2)
```

# Solution2
- **核心思想：DP**
- 递推公式如下
```java
// dp[i]表示以nums[i]结尾(子序列中一定包含nums[i])的最长单调子序列长度
for(int i = 0; i < nums.length; ++i){
    for(int j = 0; j < i; ++j){
        if(nums[i] > nums[j] && dp[i] < dp[j] + 1)
            dp[i] = dp[j] + 1;
    }
}
//时间复杂度O(n^2)
```

# Solution3
- **核心思想：贪心+二分搜索**
- 贪心：为了使子序列尽可能的长，所以我们希望当前得到的子序列的最后一个元素(最大值)尽可能的小。
  - 定义tails[]数组表示当前获得的子序列,tails[k]表示长度为k+1的子序列中的最大值，可以通过反证法证明该数组一定严格单调。
  - 步骤：
    - 将原数组第一个元素放入tails。
    - 对余下元素进行遍历，利用二分搜索在tails中搜索出tails[j] > nums[i]的最小的j。
    - 如果这样的j存在，则tails[j] = nums[i]
    - 如果不存在，则代表当前tails中元素都小于nums[i]，可以将其插入tails尾部
    - 结果为tails序列长度。
  - 时间复杂度$O(n \log n)$
